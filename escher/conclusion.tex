\section{Conclusion}

%As applications become more distributed and complex, their scheduling requirements become increasingly demanding and entangled.
Designing cluster scheduling frameworks that can evolve with changing requirements of applications presents a three way trade-off between evolvability, application simplicity and performance. 
%Distributed execution frameworks must equip these applications with flexible and adaptable means to express their scheduling objectives
With \textit{ephemeral resources}, \name{} marks a new point in this design space which makes cluster frameworks evolvable by allowing applications to implement a wide range of scheduling policies without taking on the complexities of scheduler design and implementation. This gain in evolvability is valuable for many applications, for whom functionality in the short-term (while the policy is integrated into the scheduler) may be more important than performance. %including those with complex compositions of hierarchical and dynamic policies. 
% This is done via  dynamically create ephemeral resources and utilizing the core resource-matching functionality of cluster schedulers,
Further, ESCHER Scheduling Libraries (ESLs) reduce application level complexity by encapsulating policy implementations in a portable layer. Finally, we implement \name{} on Kubernetes and Ray to illustrate the generality of \name{} and achieve performance comparable to hard-coded schedulers on a variety of machine learning and data processing workloads. 

%With an efficient lock-free implementation of the \lstinline{set_resource} primitive, the use of ephemeral resources has minimal impact on the performance of applications or the core scheduler. Rather, by pushing out scheduling policies to the application layer, the core framework scheduler can be kept minimal, promoting maintainability and performance at scale~\cite{ray}. Overall, \name{} presents a clean scheduling abstraction---ephemeral resources---which grants applications the flexibility to express arbitrary scheduling objectives while minimizing the implementation burden on both the application and the core scheduler.

%Most distributed execution frameworks expect applications to completely take over the scheduling control by creating a tight coupling between physical resources and tasks. This makes the application code complex and make fault-tolerance intractable. Worse, adding a new policy and evolving the scheduler gets increasingly onerous with the range of policies implemented in the scheduler. \name{} addresses this challenge common to existing frameworks and schedulers and presents a clean abstraction which provides flexibility to express arbitrary scheduling policies while concealing the complexity associated with implementing a scheduler.
As distributed applications become increasingly complex, so do their scheduling requirements. This development calls for cluster schedulers that are not only general, but also evolvable. Unfortunately, most existing cluster schedulers are not evolvable: when confronted with new requirements, they need major rewrites to support these requirements. Examples include gang-scheduling support in Kubernetes~\cite{spark-ganscheduling, kubernetes} or task-affinity in Spark~\cite{spark-ganscheduling}. Some cluster schedulers~\cite{omega,mesos} expose physical resources to applications to address this. While these approaches are evolvable, they push the burden of implementing scheduling mechanisms in addition to the policies entirely to the application.

\name{} is a cluster scheduler design that achieves both evolvability and application-level simplicity. \name{} uses an abstraction exposed by several recent frameworks (which we call \textit{ephemeral resources}) that lets the application express scheduling constraints as resource requirements. These requirements are then satisfied by a simple mechanism matching resource demands to available resources. We implement \name{} on Kubernetes and Ray, and show that this abstraction can be used to express common policies offered by monolithic schedulers while allowing applications to easily create new custom policies hitherto unsupported.